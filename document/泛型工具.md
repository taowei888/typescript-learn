### src/generics-tool.ts
实现了以下工具类型的学习和自定义实现：

#### 1. Partial<T>
- **功能**: 将类型的所有属性变为可选属性
- **自定义实现**: `MyPartial<T>`
- **核心语法**: `[P in keyof T]?: T[P]`

```typescript
type MyPartial<T> = {
    [P in keyof T]?: T[P]
}
```

#### 2. Required<T>
- **功能**: 将可选属性变为必选属性
- **自定义实现**: `MyRequired<T>`
- **核心语法**: `[P in keyof T]-?: T[P]` (使用 `-?` 移除可选修饰符)

#### 3. Pick<T, K>
- **功能**: 从类型中选取指定的属性
- **自定义实现**: `MyPick<T, K extends keyof T>`
- **核心语法**: `[P in K]: T[P]`

#### 4. Exclude<T, U>
- **功能**: 从联合类型中排除指定类型
- **自定义实现**: `MyExclude<T, K>`
- **核心语法**: `T extends K ? never : T`
- **关键概念**: never 在联合类型中会被自动排除

#### 5. Omit<T, K>
- **功能**: 创建新类型，排除指定属性
- **自定义实现**: `MyOmit<T, K extends keyof T>`
- **实现方式**: 结合 Pick 和 Exclude: `MyPick<T, MyExclude<keyof T, K>>`

#### 6. Record<K, T>
- **功能**: 约束对象的 key 和 value 类型
- **自定义实现**: `MyRecord<T extends ObjKey, K>`
- **核心概念**: `keyof any` 等于 `string | number | symbol`
- **使用场景**: 创建具有特定键值对类型的对象

#### 7. ReturnType<T>
- **功能**: 获取函数的返回值类型
- **自定义实现**: `MyReturnType<F extends Function>`
- **核心语法**: `F extends (...args: any) => infer R ? R : never`
- **关键点**: 结合 `typeof` 将具体函数转换为类型

## 学习要点

### 1. 映射类型 (Mapped Types)
```typescript
[P in keyof T]: T[P]  // 基本映射
[P in keyof T]?: T[P] // 可选映射
[P in keyof T]-?: T[P] // 移除可选修饰符
```

### 2. 条件类型与 never
- never 类型在联合类型中会被自动排除
- 条件类型配合 never 可以实现类型过滤

### 3. 类型约束
- `K extends keyof T` 确保 K 是 T 的键
- `T extends Function` 约束 T 必须是函数类型

### 4. 类型推断 (infer)
- 在条件类型中推断类型
- 常用于提取函数返回值、Promise 内部类型等

## 实际应用示例

```typescript
// Record 的嵌套使用
let obj2: Record<Key, Record<Key, Value>> = {
    "c": {
        "c": '唱',
        "x": '跳', 
        "k": '篮球'
    },
    // ...
}

// ReturnType 提取函数返回值类型
const fn = () => ['a', 1, true]
type test13 = ReturnType<typeof fn> // (string | number | boolean)[]
```

## 总结

本次提交系统性地学习了 TypeScript 的核心工具类型，通过自定义实现加深了对类型系统底层机制的理解。这些工具类型是 TypeScript 开发中的重要基础，掌握它们对于编写类型安全的代码至关重要。